import * as fs from 'fs-extra';
import * as path from 'path';

interface CursorMemory {
  id: string;
  title: string;
  content: string;
  category: string;
  tags: string[];
  createdAt: string;
  updatedAt: string;
}

interface SaveMemoryArgs {
  title: string;
  content: string;
  category?: string;
  tags?: string[];
}

interface GetMemoriesArgs {
  category?: string;
  tag?: string;
  limit?: number;
}

export class CursorMemoryTool {
  private cursorDir: string;
  private memoriesFile: string;

  constructor() {
    // åœ¨é¡¹ç›®æ ¹ç›®å½•ä¸‹åˆ›å»º.cursorç›®å½•
    this.cursorDir = path.join(process.cwd(), '.cursor');
    this.memoriesFile = path.join(this.cursorDir, 'memories.json');
    this.ensureCursorDirectory();
  }

  async saveMemory(args: SaveMemoryArgs) {
    try {
      const memories = await this.loadMemories();
      
      // ç”Ÿæˆå‹å¥½çš„æ–‡ä»¶åï¼ˆåŸºäºæ ‡é¢˜å’Œæ—¶é—´æˆ³ï¼‰
      const timestamp = new Date().toISOString().slice(0, 19).replace(/[T:]/g, '-');
      const safeTitle = args.title
        .toLowerCase()
        .replace(/[^a-z0-9\u4e00-\u9fa5]/g, '-')  // æ”¯æŒä¸­æ–‡
        .replace(/-+/g, '-')
        .replace(/^-|-$/g, '')
        .substring(0, 50);
      
      const filename = `${timestamp}_${safeTitle}.md`;
      const memoryId = this.generateId();
      
      const newMemory: CursorMemory = {
        id: memoryId,
        title: args.title,
        content: args.content,
        category: args.category || 'conversation',
        tags: args.tags || [],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };

      memories.push(newMemory);
      await this.saveMemories(memories);

      // åˆ›å»ºå…·æœ‰å‹å¥½æ–‡ä»¶åçš„è®°å¿†æ–‡ä»¶
      await this.createMemoryFileWithName(newMemory, filename);

      // è¿”å›è¯¦ç»†çš„ä¿å­˜ä¿¡æ¯ï¼ŒåŒ…æ‹¬ç¡®åˆ‡çš„æ–‡ä»¶å
      const filePath = `.cursor/memories/${filename}`;
      return {
        content: [
          {
            type: "text",
            text: `âœ… **è®°å¿†ä¿å­˜æˆåŠŸï¼**\n\nğŸ“ **ä¿å­˜ä½ç½®ï¼š** \`${filePath}\`\nğŸ“ **æ ‡é¢˜ï¼š** ${newMemory.title}\nğŸ·ï¸ **åˆ†ç±»ï¼š** ${newMemory.category}\nğŸ· **æ ‡ç­¾ï¼š** ${newMemory.tags.length > 0 ? newMemory.tags.join(', ') : 'æ— '}\nğŸ†” **è®°å¿†IDï¼š** ${newMemory.id}\nâ° **åˆ›å»ºæ—¶é—´ï¼š** ${new Date(newMemory.createdAt).toLocaleString()}\n\nğŸ¯ **è¯´æ˜ï¼š** è¿™ä¸ªè®°å¿†å·²ç»è¢«ä¿å­˜åˆ°ä½ çš„ Cursor å·¥ä½œåŒºçš„ \`.cursor\` ç›®å½•ä¸­ï¼ŒCursor AI å¯ä»¥è®¿é—®å¹¶åˆ©ç”¨è¿™äº›ä¿¡æ¯æä¾›æ›´å¥½çš„ä¸Šä¸‹æ–‡æ”¯æŒã€‚\n\nğŸ“„ **æ–‡ä»¶å†…å®¹å·²æ ¼å¼åŒ–ä¸º Markdown æ ¼å¼**ï¼Œä¾¿äºé˜…è¯»å’ŒAIç†è§£ã€‚`,
          },
        ],
      };
    } catch (error) {
      throw new Error(`Failed to save memory: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  async getMemories(args: GetMemoriesArgs) {
    try {
      const memories = await this.loadMemories();
      let filteredMemories = memories;

      // æŒ‰ç±»åˆ«è¿‡æ»¤
      if (args.category) {
        filteredMemories = filteredMemories.filter(m => 
          m.category.toLowerCase().includes(args.category!.toLowerCase())
        );
      }

      // æŒ‰æ ‡ç­¾è¿‡æ»¤
      if (args.tag) {
        filteredMemories = filteredMemories.filter(m => 
          m.tags.some(tag => tag.toLowerCase().includes(args.tag!.toLowerCase()))
        );
      }

      // æŒ‰æ—¶é—´æ’åºï¼ˆæœ€æ–°çš„åœ¨å‰ï¼‰
      filteredMemories.sort((a, b) => 
        new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
      );

      // é™åˆ¶æ•°é‡
      const limit = args.limit || 10;
      filteredMemories = filteredMemories.slice(0, limit);

      const output = this.formatMemoriesOutput(filteredMemories);

      return {
        content: [
          {
            type: "text",
            text: output,
          },
        ],
      };
    } catch (error) {
      throw new Error(`Failed to get memories: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  private async ensureCursorDirectory(): Promise<void> {
    await fs.ensureDir(this.cursorDir);
    await fs.ensureDir(path.join(this.cursorDir, 'memories'));
    
    // åˆ›å»º.cursor/README.mdè¯´æ˜æ–‡ä»¶
    const readmePath = path.join(this.cursorDir, 'README.md');
    if (!await fs.pathExists(readmePath)) {
      const readmeContent = `# Cursor Memories

This directory contains memories saved by the Link MCP server.

## Structure

- \`memories.json\` - Index of all memories
- \`memories/\` - Individual memory files in Markdown format
- \`conversations/\` - Conversation summaries

## Usage

These files are designed to be read by Cursor's AI to provide context and memory across sessions.

## Categories

- **conversation** - Conversation summaries and important discussions
- **documentation** - Documentation and API references
- **code-patterns** - Code patterns and solutions
- **project-notes** - Project-specific notes and decisions

Generated by Link MCP Server
`;
      await fs.writeFile(readmePath, readmeContent);
    }
  }

  private async loadMemories(): Promise<CursorMemory[]> {
    try {
      if (await fs.pathExists(this.memoriesFile)) {
        const data = await fs.readFile(this.memoriesFile, 'utf-8');
        return JSON.parse(data);
      }
      return [];
    } catch (error) {
      console.error('Error loading memories:', error);
      return [];
    }
  }

  private async saveMemories(memories: CursorMemory[]): Promise<void> {
    await fs.writeFile(this.memoriesFile, JSON.stringify(memories, null, 2));
  }

  private async createMemoryFileWithName(memory: CursorMemory, filename: string): Promise<void> {
    const memoriesDir = path.join(this.cursorDir, 'memories');
    const filepath = path.join(memoriesDir, filename);

    const content = `# ${memory.title}

**åˆ†ç±»ï¼š** ${memory.category}
**æ ‡ç­¾ï¼š** ${memory.tags.length > 0 ? memory.tags.join(', ') : 'æ— æ ‡ç­¾'}
**åˆ›å»ºæ—¶é—´ï¼š** ${new Date(memory.createdAt).toLocaleString()}
**æ›´æ–°æ—¶é—´ï¼š** ${new Date(memory.updatedAt).toLocaleString()}
**è®°å¿†IDï¼š** ${memory.id}

---

## ğŸ“ è®°å¿†å†…å®¹

${memory.content}

---

## ğŸ“‹ å…ƒæ•°æ®

- **æ–‡ä»¶åï¼š** ${filename}
- **æ–‡ä»¶è·¯å¾„ï¼š** .cursor/memories/${filename}
- **ç”Ÿæˆå™¨ï¼š** Link MCP Server
- **ç”¨é€”ï¼š** ä¸º Cursor AI æä¾›ä¸Šä¸‹æ–‡è®°å¿†

> ğŸ’¡ **æç¤ºï¼š** è¿™ä¸ªæ–‡ä»¶è¢«è®¾è®¡ä¸ºå¯è¢« Cursor AI è¯»å–å’Œç†è§£çš„æ ¼å¼ï¼ŒåŒ…å«äº†å®Œæ•´çš„ä¸Šä¸‹æ–‡ä¿¡æ¯å’Œå…ƒæ•°æ®ã€‚
`;

    await fs.writeFile(filepath, content);
  }

  private generateId(): string {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  }

  private formatMemoriesOutput(memories: CursorMemory[]): string {
    if (memories.length === 0) {
      return "No memories found matching your criteria.";
    }

    let output = `# Cursor Memories (${memories.length} found)\n\n`;

    memories.forEach((memory, index) => {
      output += `## ${index + 1}. ${memory.title}\n\n`;
      output += `**Category:** ${memory.category}\n`;
      output += `**Tags:** ${memory.tags.join(', ')}\n`;
      output += `**Created:** ${new Date(memory.createdAt).toLocaleString()}\n`;
      output += `**File:** .cursor/memories/${memory.id}.md\n\n`;
      
      // æ˜¾ç¤ºå†…å®¹é¢„è§ˆï¼ˆå‰200å­—ç¬¦ï¼‰
      const preview = memory.content.length > 200 
        ? memory.content.substring(0, 200) + '...'
        : memory.content;
      output += `**Preview:** ${preview}\n\n`;
      output += `---\n\n`;
    });

    return output;
  }

  // è¾…åŠ©æ–¹æ³•ï¼šè‡ªåŠ¨æ€»ç»“å¯¹è¯å¹¶ä¿å­˜
  async saveConversationSummary(conversation: string, topic?: string): Promise<void> {
    const title = topic || `Conversation Summary - ${new Date().toLocaleDateString()}`;
    
    // ç®€å•çš„å¯¹è¯æ€»ç»“é€»è¾‘
    const summary = this.summarizeConversation(conversation);
    
    await this.saveMemory({
      title,
      content: `## Original Conversation\n\n${conversation}\n\n## Summary\n\n${summary}`,
      category: 'conversation',
      tags: ['auto-generated', 'conversation-summary']
    });
  }

  private summarizeConversation(conversation: string): string {
    // ç®€å•çš„æ€»ç»“é€»è¾‘ - åœ¨å®é™…åº”ç”¨ä¸­å¯ä»¥é›†æˆAIæ€»ç»“
    const lines = conversation.split('\n');
    const importantLines = lines.filter(line => 
      line.includes('user:') || 
      line.includes('assistant:') || 
      line.length > 50
    );

    return `This conversation contained ${lines.length} lines of discussion. Found ${importantLines.length} important exchanges. Key topics and actions were discussed.`;
  }
}