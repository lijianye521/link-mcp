import * as fs from 'fs-extra';
import * as path from 'path';

interface CursorMemory {
  id: string;
  title: string;
  content: string;
  category: string;
  tags: string[];
  createdAt: string;
  updatedAt: string;
}

interface SaveMemoryArgs {
  title: string;
  content: string;
  category?: string;
  tags?: string[];
}

interface GetMemoriesArgs {
  category?: string;
  tag?: string;
  limit?: number;
}

export class CursorMemoryTool {
  private cursorDir: string;
  private memoriesFile: string;

  constructor() {
    // 在项目根目录下创建.cursor目录
    this.cursorDir = path.join(process.cwd(), '.cursor');
    this.memoriesFile = path.join(this.cursorDir, 'memories.json');
    this.ensureCursorDirectory();
  }

  async saveMemory(args: SaveMemoryArgs) {
    try {
      const memories = await this.loadMemories();
      
      const newMemory: CursorMemory = {
        id: this.generateId(),
        title: args.title,
        content: args.content,
        category: args.category || 'conversation',
        tags: args.tags || [],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };

      memories.push(newMemory);
      await this.saveMemories(memories);

      // 同时创建单独的记忆文件
      await this.createMemoryFile(newMemory);

      return {
        content: [
          {
            type: "text",
            text: `✅ Memory saved successfully!\n\n**Title:** ${newMemory.title}\n**Category:** ${newMemory.category}\n**ID:** ${newMemory.id}\n**File:** .cursor/memories/${newMemory.id}.md\n\nThis memory has been saved to your Cursor workspace and can be accessed by Cursor's AI.`,
          },
        ],
      };
    } catch (error) {
      throw new Error(`Failed to save memory: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  async getMemories(args: GetMemoriesArgs) {
    try {
      const memories = await this.loadMemories();
      let filteredMemories = memories;

      // 按类别过滤
      if (args.category) {
        filteredMemories = filteredMemories.filter(m => 
          m.category.toLowerCase().includes(args.category!.toLowerCase())
        );
      }

      // 按标签过滤
      if (args.tag) {
        filteredMemories = filteredMemories.filter(m => 
          m.tags.some(tag => tag.toLowerCase().includes(args.tag!.toLowerCase()))
        );
      }

      // 按时间排序（最新的在前）
      filteredMemories.sort((a, b) => 
        new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
      );

      // 限制数量
      const limit = args.limit || 10;
      filteredMemories = filteredMemories.slice(0, limit);

      const output = this.formatMemoriesOutput(filteredMemories);

      return {
        content: [
          {
            type: "text",
            text: output,
          },
        ],
      };
    } catch (error) {
      throw new Error(`Failed to get memories: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  private async ensureCursorDirectory(): Promise<void> {
    await fs.ensureDir(this.cursorDir);
    await fs.ensureDir(path.join(this.cursorDir, 'memories'));
    
    // 创建.cursor/README.md说明文件
    const readmePath = path.join(this.cursorDir, 'README.md');
    if (!await fs.pathExists(readmePath)) {
      const readmeContent = `# Cursor Memories

This directory contains memories saved by the Link MCP server.

## Structure

- \`memories.json\` - Index of all memories
- \`memories/\` - Individual memory files in Markdown format
- \`conversations/\` - Conversation summaries

## Usage

These files are designed to be read by Cursor's AI to provide context and memory across sessions.

## Categories

- **conversation** - Conversation summaries and important discussions
- **documentation** - Documentation and API references
- **code-patterns** - Code patterns and solutions
- **project-notes** - Project-specific notes and decisions

Generated by Link MCP Server
`;
      await fs.writeFile(readmePath, readmeContent);
    }
  }

  private async loadMemories(): Promise<CursorMemory[]> {
    try {
      if (await fs.pathExists(this.memoriesFile)) {
        const data = await fs.readFile(this.memoriesFile, 'utf-8');
        return JSON.parse(data);
      }
      return [];
    } catch (error) {
      console.error('Error loading memories:', error);
      return [];
    }
  }

  private async saveMemories(memories: CursorMemory[]): Promise<void> {
    await fs.writeFile(this.memoriesFile, JSON.stringify(memories, null, 2));
  }

  private async createMemoryFile(memory: CursorMemory): Promise<void> {
    const memoriesDir = path.join(this.cursorDir, 'memories');
    const filename = `${memory.id}.md`;
    const filepath = path.join(memoriesDir, filename);

    const content = `# ${memory.title}

**Category:** ${memory.category}
**Tags:** ${memory.tags.join(', ')}
**Created:** ${new Date(memory.createdAt).toLocaleString()}
**Updated:** ${new Date(memory.updatedAt).toLocaleString()}

---

${memory.content}

---

*Memory ID: ${memory.id}*
*Generated by Link MCP Server*
`;

    await fs.writeFile(filepath, content);
  }

  private generateId(): string {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  }

  private formatMemoriesOutput(memories: CursorMemory[]): string {
    if (memories.length === 0) {
      return "No memories found matching your criteria.";
    }

    let output = `# Cursor Memories (${memories.length} found)\n\n`;

    memories.forEach((memory, index) => {
      output += `## ${index + 1}. ${memory.title}\n\n`;
      output += `**Category:** ${memory.category}\n`;
      output += `**Tags:** ${memory.tags.join(', ')}\n`;
      output += `**Created:** ${new Date(memory.createdAt).toLocaleString()}\n`;
      output += `**File:** .cursor/memories/${memory.id}.md\n\n`;
      
      // 显示内容预览（前200字符）
      const preview = memory.content.length > 200 
        ? memory.content.substring(0, 200) + '...'
        : memory.content;
      output += `**Preview:** ${preview}\n\n`;
      output += `---\n\n`;
    });

    return output;
  }

  // 辅助方法：自动总结对话并保存
  async saveConversationSummary(conversation: string, topic?: string): Promise<void> {
    const title = topic || `Conversation Summary - ${new Date().toLocaleDateString()}`;
    
    // 简单的对话总结逻辑
    const summary = this.summarizeConversation(conversation);
    
    await this.saveMemory({
      title,
      content: `## Original Conversation\n\n${conversation}\n\n## Summary\n\n${summary}`,
      category: 'conversation',
      tags: ['auto-generated', 'conversation-summary']
    });
  }

  private summarizeConversation(conversation: string): string {
    // 简单的总结逻辑 - 在实际应用中可以集成AI总结
    const lines = conversation.split('\n');
    const importantLines = lines.filter(line => 
      line.includes('user:') || 
      line.includes('assistant:') || 
      line.length > 50
    );

    return `This conversation contained ${lines.length} lines of discussion. Found ${importantLines.length} important exchanges. Key topics and actions were discussed.`;
  }
}