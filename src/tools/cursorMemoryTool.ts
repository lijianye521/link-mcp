import * as fs from 'fs-extra';
import * as path from 'path';

interface CursorMemory {
  id: string;
  title: string;
  content: string;
  category: string;
  tags: string[];
  createdAt: string;
  updatedAt: string;
}

interface SaveMemoryArgs {
  title: string;
  content: string;
  category?: string;
  tags?: string[];
}

interface GetMemoriesArgs {
  category?: string;
  tag?: string;
  limit?: number;
}

export class CursorMemoryTool {
  private cursorDir: string;
  private memoriesFile: string;

  constructor() {
    // 在项目根目录下创建.cursor目录
    this.cursorDir = path.join(process.cwd(), '.cursor');
    this.memoriesFile = path.join(this.cursorDir, 'memories.json');
    this.ensureCursorDirectory();
  }

  async saveMemory(args: SaveMemoryArgs) {
    try {
      const memories = await this.loadMemories();
      
      // 生成友好的文件名（基于标题和时间戳）
      const timestamp = new Date().toISOString().slice(0, 19).replace(/[T:]/g, '-');
      const safeTitle = args.title
        .toLowerCase()
        .replace(/[^a-z0-9\u4e00-\u9fa5]/g, '-')  // 支持中文
        .replace(/-+/g, '-')
        .replace(/^-|-$/g, '')
        .substring(0, 50);
      
      const filename = `${timestamp}_${safeTitle}.md`;
      const memoryId = this.generateId();
      
      const newMemory: CursorMemory = {
        id: memoryId,
        title: args.title,
        content: args.content,
        category: args.category || 'conversation',
        tags: args.tags || [],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };

      memories.push(newMemory);
      await this.saveMemories(memories);

      // 创建具有友好文件名的记忆文件
      await this.createMemoryFileWithName(newMemory, filename);

      // 返回详细的保存信息，包括确切的文件名
      const filePath = `.cursor/memories/${filename}`;
      return {
        content: [
          {
            type: "text",
            text: `✅ **记忆保存成功！**\n\n📁 **保存位置：** \`${filePath}\`\n📝 **标题：** ${newMemory.title}\n🏷️ **分类：** ${newMemory.category}\n🏷 **标签：** ${newMemory.tags.length > 0 ? newMemory.tags.join(', ') : '无'}\n🆔 **记忆ID：** ${newMemory.id}\n⏰ **创建时间：** ${new Date(newMemory.createdAt).toLocaleString()}\n\n🎯 **说明：** 这个记忆已经被保存到你的 Cursor 工作区的 \`.cursor\` 目录中，Cursor AI 可以访问并利用这些信息提供更好的上下文支持。\n\n📄 **文件内容已格式化为 Markdown 格式**，便于阅读和AI理解。`,
          },
        ],
      };
    } catch (error) {
      throw new Error(`Failed to save memory: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  async getMemories(args: GetMemoriesArgs) {
    try {
      const memories = await this.loadMemories();
      let filteredMemories = memories;

      // 按类别过滤
      if (args.category) {
        filteredMemories = filteredMemories.filter(m => 
          m.category.toLowerCase().includes(args.category!.toLowerCase())
        );
      }

      // 按标签过滤
      if (args.tag) {
        filteredMemories = filteredMemories.filter(m => 
          m.tags.some(tag => tag.toLowerCase().includes(args.tag!.toLowerCase()))
        );
      }

      // 按时间排序（最新的在前）
      filteredMemories.sort((a, b) => 
        new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
      );

      // 限制数量
      const limit = args.limit || 10;
      filteredMemories = filteredMemories.slice(0, limit);

      const output = this.formatMemoriesOutput(filteredMemories);

      return {
        content: [
          {
            type: "text",
            text: output,
          },
        ],
      };
    } catch (error) {
      throw new Error(`Failed to get memories: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  private async ensureCursorDirectory(): Promise<void> {
    await fs.ensureDir(this.cursorDir);
    await fs.ensureDir(path.join(this.cursorDir, 'memories'));
    
    // 创建.cursor/README.md说明文件
    const readmePath = path.join(this.cursorDir, 'README.md');
    if (!await fs.pathExists(readmePath)) {
      const readmeContent = `# Cursor Memories

This directory contains memories saved by the Link MCP server.

## Structure

- \`memories.json\` - Index of all memories
- \`memories/\` - Individual memory files in Markdown format
- \`conversations/\` - Conversation summaries

## Usage

These files are designed to be read by Cursor's AI to provide context and memory across sessions.

## Categories

- **conversation** - Conversation summaries and important discussions
- **documentation** - Documentation and API references
- **code-patterns** - Code patterns and solutions
- **project-notes** - Project-specific notes and decisions

Generated by Link MCP Server
`;
      await fs.writeFile(readmePath, readmeContent);
    }
  }

  private async loadMemories(): Promise<CursorMemory[]> {
    try {
      if (await fs.pathExists(this.memoriesFile)) {
        const data = await fs.readFile(this.memoriesFile, 'utf-8');
        return JSON.parse(data);
      }
      return [];
    } catch (error) {
      console.error('Error loading memories:', error);
      return [];
    }
  }

  private async saveMemories(memories: CursorMemory[]): Promise<void> {
    await fs.writeFile(this.memoriesFile, JSON.stringify(memories, null, 2));
  }

  private async createMemoryFileWithName(memory: CursorMemory, filename: string): Promise<void> {
    const memoriesDir = path.join(this.cursorDir, 'memories');
    const filepath = path.join(memoriesDir, filename);

    const content = `# ${memory.title}

**分类：** ${memory.category}
**标签：** ${memory.tags.length > 0 ? memory.tags.join(', ') : '无标签'}
**创建时间：** ${new Date(memory.createdAt).toLocaleString()}
**更新时间：** ${new Date(memory.updatedAt).toLocaleString()}
**记忆ID：** ${memory.id}

---

## 📝 记忆内容

${memory.content}

---

## 📋 元数据

- **文件名：** ${filename}
- **文件路径：** .cursor/memories/${filename}
- **生成器：** Link MCP Server
- **用途：** 为 Cursor AI 提供上下文记忆

> 💡 **提示：** 这个文件被设计为可被 Cursor AI 读取和理解的格式，包含了完整的上下文信息和元数据。
`;

    await fs.writeFile(filepath, content);
  }

  private generateId(): string {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  }

  private formatMemoriesOutput(memories: CursorMemory[]): string {
    if (memories.length === 0) {
      return "No memories found matching your criteria.";
    }

    let output = `# Cursor Memories (${memories.length} found)\n\n`;

    memories.forEach((memory, index) => {
      output += `## ${index + 1}. ${memory.title}\n\n`;
      output += `**Category:** ${memory.category}\n`;
      output += `**Tags:** ${memory.tags.join(', ')}\n`;
      output += `**Created:** ${new Date(memory.createdAt).toLocaleString()}\n`;
      output += `**File:** .cursor/memories/${memory.id}.md\n\n`;
      
      // 显示内容预览（前200字符）
      const preview = memory.content.length > 200 
        ? memory.content.substring(0, 200) + '...'
        : memory.content;
      output += `**Preview:** ${preview}\n\n`;
      output += `---\n\n`;
    });

    return output;
  }

  // 辅助方法：自动总结对话并保存
  async saveConversationSummary(conversation: string, topic?: string): Promise<void> {
    const title = topic || `Conversation Summary - ${new Date().toLocaleDateString()}`;
    
    // 简单的对话总结逻辑
    const summary = this.summarizeConversation(conversation);
    
    await this.saveMemory({
      title,
      content: `## Original Conversation\n\n${conversation}\n\n## Summary\n\n${summary}`,
      category: 'conversation',
      tags: ['auto-generated', 'conversation-summary']
    });
  }

  private summarizeConversation(conversation: string): string {
    // 简单的总结逻辑 - 在实际应用中可以集成AI总结
    const lines = conversation.split('\n');
    const importantLines = lines.filter(line => 
      line.includes('user:') || 
      line.includes('assistant:') || 
      line.length > 50
    );

    return `This conversation contained ${lines.length} lines of discussion. Found ${importantLines.length} important exchanges. Key topics and actions were discussed.`;
  }
}